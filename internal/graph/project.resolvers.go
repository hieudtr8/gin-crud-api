package graph

// This file will be automatically regenerated based on the schema, any resolver implementations
// will be copied through when generating and any unknown code will be moved to the end.
// Code generated by github.com/99designs/gqlgen version v0.17.82

import (
	"context"
	"errors"
	"fmt"
	"gin-crud-api/internal/database"
	"gin-crud-api/internal/graph/model"
	"gin-crud-api/internal/logger"
	"gin-crud-api/internal/middleware"
	"time"

	"github.com/google/uuid"
)

// CreateProject is the resolver for the createProject field.
func (r *mutationResolver) CreateProject(ctx context.Context, input model.CreateProjectInput) (*model.Project, error) {
	requestID := middleware.GetRequestID(ctx)
	log := logger.WithRequestID(requestID)

	log.Info().
		Str("operation", "createProject").
		Str("name", input.Name).
		Msg("Creating project")

	// Validate required fields
	if input.Name == "" {
		log.Error().Msg("Validation failed: project name is required")
		return nil, errors.New("project name is required")
	}

	if input.Budget <= 0 {
		log.Error().Msg("Validation failed: budget must be positive")
		return nil, errors.New("budget must be positive")
	}

	// Validate and parse dates
	startDate, err := time.Parse("2006-01-02", input.StartDate)
	if err != nil {
		log.Error().Err(err).Msg("Invalid start date format")
		return nil, fmt.Errorf("invalid start date format (use YYYY-MM-DD): %w", err)
	}

	endDate, err := time.Parse("2006-01-02", input.EndDate)
	if err != nil {
		log.Error().Err(err).Msg("Invalid end date format")
		return nil, fmt.Errorf("invalid end date format (use YYYY-MM-DD): %w", err)
	}

	// Validate date logic
	if endDate.Before(startDate) {
		log.Error().Msg("Validation failed: end date must be after start date")
		return nil, errors.New("end date must be after start date")
	}

	// Set default values for optional fields
	status := model.ProjectStatusActive
	if input.Status != nil {
		status = *input.Status
	}

	priority := model.ProjectPriorityMedium
	if input.Priority != nil {
		priority = *input.Priority
	}

	// Validate team members exist
	var teamMembers []*model.Employee
	if len(input.TeamMemberIDs) > 0 {
		for _, empID := range input.TeamMemberIDs {
			emp, err := r.EmpRepo.FindByID(empID)
			if err != nil {
				if errors.Is(err, database.ErrNotFound) {
					log.Error().Str("employee_id", empID).Msg("Employee not found")
					return nil, fmt.Errorf("employee with ID %s not found", empID)
				}
				log.Error().Err(err).Msg("Failed to validate employee")
				return nil, fmt.Errorf("failed to validate employee: %w", err)
			}
			teamMembers = append(teamMembers, emp)
		}
	}

	// Create project model
	project := &model.Project{
		ID:          uuid.New().String(),
		Name:        input.Name,
		Status:      status,
		Priority:    priority,
		StartDate:   input.StartDate,
		EndDate:     input.EndDate,
		Budget:      input.Budget,
		TeamMembers: teamMembers,
	}

	if input.Description != nil {
		project.Description = input.Description
	}

	// Save to repository
	if err := r.ProjRepo.Save(project); err != nil {
		log.Error().Err(err).Msg("Failed to save project")
		return nil, fmt.Errorf("failed to create project: %w", err)
	}

	log.Info().
		Str("project_id", project.ID).
		Str("name", project.Name).
		Msg("Project created successfully")

	return project, nil
}

// UpdateProject is the resolver for the updateProject field.
func (r *mutationResolver) UpdateProject(ctx context.Context, id string, input model.UpdateProjectInput) (*model.Project, error) {
	requestID := middleware.GetRequestID(ctx)
	log := logger.WithRequestID(requestID)

	log.Info().
		Str("operation", "updateProject").
		Str("project_id", id).
		Msg("Updating project")

	// Check if project exists
	existing, err := r.ProjRepo.FindByID(id)
	if err != nil {
		if errors.Is(err, database.ErrNotFound) {
			log.Error().Str("project_id", id).Msg("Project not found")
			return nil, fmt.Errorf("project with ID %s not found", id)
		}
		log.Error().Err(err).Msg("Failed to find project")
		return nil, fmt.Errorf("failed to find project: %w", err)
	}

	// Apply updates (only update provided fields)
	if input.Name != nil {
		if *input.Name == "" {
			return nil, errors.New("project name cannot be empty")
		}
		existing.Name = *input.Name
	}

	if input.Description != nil {
		existing.Description = input.Description
	}

	if input.Status != nil {
		existing.Status = *input.Status
	}

	if input.Priority != nil {
		existing.Priority = *input.Priority
	}

	if input.StartDate != nil {
		startDate, err := time.Parse("2006-01-02", *input.StartDate)
		if err != nil {
			return nil, fmt.Errorf("invalid start date format (use YYYY-MM-DD): %w", err)
		}
		existing.StartDate = startDate.Format("2006-01-02")
	}

	if input.EndDate != nil {
		endDate, err := time.Parse("2006-01-02", *input.EndDate)
		if err != nil {
			return nil, fmt.Errorf("invalid end date format (use YYYY-MM-DD): %w", err)
		}
		existing.EndDate = endDate.Format("2006-01-02")
	}

	// Validate date logic if both dates are present
	startDate, _ := time.Parse("2006-01-02", existing.StartDate)
	endDate, _ := time.Parse("2006-01-02", existing.EndDate)
	if endDate.Before(startDate) {
		return nil, errors.New("end date must be after start date")
	}

	if input.Budget != nil {
		if *input.Budget <= 0 {
			return nil, errors.New("budget must be positive")
		}
		existing.Budget = *input.Budget
	}

	// Update team members if provided
	if input.TeamMemberIDs != nil {
		var teamMembers []*model.Employee
		for _, empID := range input.TeamMemberIDs {
			emp, err := r.EmpRepo.FindByID(empID)
			if err != nil {
				if errors.Is(err, database.ErrNotFound) {
					return nil, fmt.Errorf("employee with ID %s not found", empID)
				}
				return nil, fmt.Errorf("failed to validate employee: %w", err)
			}
			teamMembers = append(teamMembers, emp)
		}
		existing.TeamMembers = teamMembers
	}

	// Save updates
	if err := r.ProjRepo.Update(existing); err != nil {
		log.Error().Err(err).Msg("Failed to update project")
		return nil, fmt.Errorf("failed to update project: %w", err)
	}

	log.Info().
		Str("project_id", id).
		Msg("Project updated successfully")

	return existing, nil
}

// DeleteProject is the resolver for the deleteProject field.
func (r *mutationResolver) DeleteProject(ctx context.Context, id string) (bool, error) {
	requestID := middleware.GetRequestID(ctx)
	log := logger.WithRequestID(requestID)

	log.Info().
		Str("operation", "deleteProject").
		Str("project_id", id).
		Msg("Deleting project")

	// Delete project
	if err := r.ProjRepo.Delete(id); err != nil {
		if errors.Is(err, database.ErrNotFound) {
			log.Error().Str("project_id", id).Msg("Project not found")
			return false, fmt.Errorf("project with ID %s not found", id)
		}
		log.Error().Err(err).Msg("Failed to delete project")
		return false, fmt.Errorf("failed to delete project: %w", err)
	}

	log.Info().
		Str("project_id", id).
		Msg("Project deleted successfully")

	return true, nil
}

// AddEmployeeToProject is the resolver for the addEmployeeToProject field.
func (r *mutationResolver) AddEmployeeToProject(ctx context.Context, projectID string, employeeID string) (*model.Project, error) {
	requestID := middleware.GetRequestID(ctx)
	log := logger.WithRequestID(requestID)

	log.Info().
		Str("operation", "addEmployeeToProject").
		Str("project_id", projectID).
		Str("employee_id", employeeID).
		Msg("Adding employee to project")

	// Verify employee exists
	_, err := r.EmpRepo.FindByID(employeeID)
	if err != nil {
		if errors.Is(err, database.ErrNotFound) {
			return nil, fmt.Errorf("employee with ID %s not found", employeeID)
		}
		return nil, fmt.Errorf("failed to validate employee: %w", err)
	}

	// Add team member
	if err := r.ProjRepo.AddTeamMember(projectID, employeeID); err != nil {
		if errors.Is(err, database.ErrNotFound) {
			return nil, fmt.Errorf("project with ID %s not found", projectID)
		}
		log.Error().Err(err).Msg("Failed to add employee to project")
		return nil, fmt.Errorf("failed to add employee to project: %w", err)
	}

	// Return updated project
	project, err := r.ProjRepo.FindByID(projectID)
	if err != nil {
		return nil, fmt.Errorf("failed to retrieve updated project: %w", err)
	}

	log.Info().
		Str("project_id", projectID).
		Str("employee_id", employeeID).
		Msg("Employee added to project successfully")

	return project, nil
}

// RemoveEmployeeFromProject is the resolver for the removeEmployeeFromProject field.
func (r *mutationResolver) RemoveEmployeeFromProject(ctx context.Context, projectID string, employeeID string) (*model.Project, error) {
	requestID := middleware.GetRequestID(ctx)
	log := logger.WithRequestID(requestID)

	log.Info().
		Str("operation", "removeEmployeeFromProject").
		Str("project_id", projectID).
		Str("employee_id", employeeID).
		Msg("Removing employee from project")

	// Remove team member
	if err := r.ProjRepo.RemoveTeamMember(projectID, employeeID); err != nil {
		if errors.Is(err, database.ErrNotFound) {
			return nil, fmt.Errorf("project with ID %s not found", projectID)
		}
		log.Error().Err(err).Msg("Failed to remove employee from project")
		return nil, fmt.Errorf("failed to remove employee from project: %w", err)
	}

	// Return updated project
	project, err := r.ProjRepo.FindByID(projectID)
	if err != nil {
		return nil, fmt.Errorf("failed to retrieve updated project: %w", err)
	}

	log.Info().
		Str("project_id", projectID).
		Str("employee_id", employeeID).
		Msg("Employee removed from project successfully")

	return project, nil
}

// Project is the resolver for the project field.
func (r *queryResolver) Project(ctx context.Context, id string) (*model.Project, error) {
	requestID := middleware.GetRequestID(ctx)
	log := logger.WithRequestID(requestID)

	log.Info().
		Str("operation", "project").
		Str("project_id", id).
		Msg("Fetching project")

	project, err := r.ProjRepo.FindByID(id)
	if err != nil {
		if errors.Is(err, database.ErrNotFound) {
			log.Debug().Str("project_id", id).Msg("Project not found")
			return nil, nil // GraphQL returns null for not found
		}
		log.Error().Err(err).Msg("Failed to fetch project")
		return nil, fmt.Errorf("failed to fetch project: %w", err)
	}

	log.Info().
		Str("project_id", id).
		Msg("Project fetched successfully")

	return project, nil
}

// Projects is the resolver for the projects field.
func (r *queryResolver) Projects(ctx context.Context) ([]*model.Project, error) {
	requestID := middleware.GetRequestID(ctx)
	log := logger.WithRequestID(requestID)

	log.Info().
		Str("operation", "projects").
		Msg("Fetching all projects")

	projects, err := r.ProjRepo.FindAll()
	if err != nil {
		log.Error().Err(err).Msg("Failed to fetch projects")
		return nil, fmt.Errorf("failed to fetch projects: %w", err)
	}

	log.Info().
		Int("count", len(projects)).
		Msg("Projects fetched successfully")

	return projects, nil
}

// ProjectsByStatus is the resolver for the projectsByStatus field.
func (r *queryResolver) ProjectsByStatus(ctx context.Context, status model.ProjectStatus) ([]*model.Project, error) {
	requestID := middleware.GetRequestID(ctx)
	log := logger.WithRequestID(requestID)

	log.Info().
		Str("operation", "projectsByStatus").
		Str("status", string(status)).
		Msg("Fetching projects by status")

	projects, err := r.ProjRepo.FindByStatus(status)
	if err != nil {
		log.Error().Err(err).Msg("Failed to fetch projects by status")
		return nil, fmt.Errorf("failed to fetch projects by status: %w", err)
	}

	log.Info().
		Str("status", string(status)).
		Int("count", len(projects)).
		Msg("Projects fetched by status successfully")

	return projects, nil
}

// ProjectsByEmployee is the resolver for the projectsByEmployee field.
func (r *queryResolver) ProjectsByEmployee(ctx context.Context, employeeID string) ([]*model.Project, error) {
	requestID := middleware.GetRequestID(ctx)
	log := logger.WithRequestID(requestID)

	log.Info().
		Str("operation", "projectsByEmployee").
		Str("employee_id", employeeID).
		Msg("Fetching projects by employee")

	// Verify employee exists
	_, err := r.EmpRepo.FindByID(employeeID)
	if err != nil {
		if errors.Is(err, database.ErrNotFound) {
			return nil, fmt.Errorf("employee with ID %s not found", employeeID)
		}
		return nil, fmt.Errorf("failed to validate employee: %w", err)
	}

	projects, err := r.ProjRepo.FindByEmployeeID(employeeID)
	if err != nil {
		log.Error().Err(err).Msg("Failed to fetch projects by employee")
		return nil, fmt.Errorf("failed to fetch projects by employee: %w", err)
	}

	log.Info().
		Str("employee_id", employeeID).
		Int("count", len(projects)).
		Msg("Projects fetched by employee successfully")

	return projects, nil
}
